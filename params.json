{"name":"Nadoni","tagline":"nAdoni is a library that provides a way to check for updates to one or more binaries via an update manifest, and then to download an archive containing the updated binaries.","body":"# nAdoni\r\n\r\nnAdoni is a library that provides a way to check for updates to one or more binaries via an update manifest, and then to download an archive containing the updated binaries. \r\n\r\nThe manifest file is an XML file which is signed with an RSA key to provide some form of security in the update process. \r\n\r\n# Setup\r\n\r\n### Create a manifest file:\r\n\r\n* Create an archive file that contains all the files that should be part of the update.\r\n* Get the `nAdoni.ManifestBuilder` executable and execute the following command line:\r\n\r\n        nAdoni.ManifestBuilder.exe --ProductName=<PRODUCT-NAME> --ProductVersion=<PRODUCT-VERSION> --FilePath=<FILE-PATH-TO-ARCHIVE-FILE> --DownloadUrl=<URL-TO-ARCHIVE-FILE> --KeyFile=<SIGNING-FILE-PATH> --KeyContainerName=<SIGNING-KEY-CONTAINER-NAME> --Output=<OUTPUT-PATH>\r\n\r\n\tWhere\r\n * __PRODUCT-NAME__ - The name of the product that should be updated. This name is not directly used in finding new updates but may be used for display purposes in the application that is checking for updates.\r\n * __PRODUCT-VERSION__ - The version of the product that is contained in the archive file. An application looking for updates will compare their version number with this one in order to determine if it should update or not.\r\n * __FILE-PATH-TO-ARCHIVE-FILE__ - The full path to the archive file, at the moment the manifest file is being created. This path is used to load the archive file and calculate the hash.\r\n * __URL-TO-ARCHIVE-FILE__ - The URL from which the archive can be downloaded. \r\n * __SIGNING-FILE-PATH__ - The full path to the RSA private key file with which the manifest file should be signed. This parameter does not need to be provided if a key container name is provided.\r\n * __SIGNING-KEY-CONTAINER-NAME__ - The name of the key container that contains the private key with which the manifest file should be signed. This parameter does not need to be provided if a key file path is provided.\r\n * __OUTPUT-PATH__ - The full path to the location where the output file should be placed.\r\n\r\n\tA RSA private key file contains the following information:\r\n\r\n\t``` xml\r\n\t<RSAKeyValue>\r\n\t    <Modulus>MODULUS_VALUE_HERE</Modulus>\r\n\t    <Exponent>EXPONENT_VALUE_HERE</Exponent>\r\n\t    <P>P_VALUE_HERE</P>\r\n\t    <Q>Q_VALUE_HERE</Q>\r\n\t    <DP>DP_VALUE_HERE</DP>\r\n\t    <DQ>DQ_VALUE_HERE</DQ>\r\n\t    <InverseQ>INVERSE_Q_VALUE_HERE</InverseQ>\r\n\t    <D>D_VALUE_HERE</D>\r\n\t</RSAKeyValue>\r\n\t```\r\n\t\r\n\tThis kind of file can be written with the following code\r\n\t\r\n\t``` c#\r\n\t\tusing (var rsa = new RSACryptoServiceProvider(s_KeySize))\r\n\t    {\r\n\t        try\r\n\t        {\r\n\t            // Write the public key file\r\n\t            using (var writer = new StreamWriter(new FileStream(s_PublicKeyFile, FileMode.Create, FileAccess.Write, FileShare.None)))\r\n\t            {\r\n\t                var publicKeyXml = rsa.ToXmlString(false);\r\n\t                writer.Write(publicKeyXml);\r\n\t            }\r\n\t\r\n\t            // Write the privat key file\r\n\t            using (var writer = new StreamWriter(new FileStream(s_PrivateKeyFile, FileMode.Create, FileAccess.Write, FileShare.None)))\r\n\t            {\r\n\t                var privateKeyXml = rsa.ToXmlString(true);\r\n\t                writer.Write(privateKeyXml);\r\n\t            }\r\n\t        }\r\n\t        finally\r\n\t        {\r\n\t            // Make sure we're not storing this key in the machine container.\r\n\t            rsa.PersistKeyInCsp = false;\r\n\t        }\r\n\t    }\r\n\t```\r\n\r\n### In the application\r\n\r\n``` c#\r\n\r\nvar updater = new NAdoni.Updater();\r\n\r\n// Check for updates\r\nvar info = updater.MostRecentUpdateOnRemoteServer(manifestUri, publicKeyXml, currentVersion);\r\n\r\nif (info.UpdateIsAvailableAndValid)\r\n{\r\n\tvar task = updater.StartDownloadAsync(info);\r\n\ttask.Wait();\r\n\r\n\tvar fileInfo = task.Result;\r\n\r\n\t// Now you have a FileInfo object with the path to your archive file\r\n}\r\n\r\n```\r\n\r\n\r\n# Installation instructions\r\n\r\nThe library section of nAdoni is available on [NuGet.org](http://www.nuget.org). And the manifest builder is available as ZIP archive from the [releases page](https://github.com/pvandervelde/nAdoni/releases).\r\n\r\n\r\n# How to build\r\n\r\nThe solution files are created in Visual Studio 2012 (using .NET 4.5) and the entire project can be build by invoking MsBuild on the nadoni.integration.msbuild script. This will build the binaries, the NuGet package and the ZIP archive. The binaries will be placed in the `build\\bin\\AnyCpu\\Release` directory and the NuGet package and the ZIP archive will be placed in the `build\\deploy` directory.\r\n\r\nNote that the build scripts assume that:\r\n\r\n* The binaries should be signed, however the SNK key file is not included in the repository so a new key file has to be [created][snkfile_msdn]. The key file is referenced through an environment variable called `SOFTWARE_SIGNING_KEY_PATH` that has as value the full path of the key file. \r\n* GIT can be found on the PATH somewhere so that it can be called to get the hash of the last commit in the current repository. This hash is embedded in the nuclei assemblies together with information about the build configuration and build time and date.\r\n\r\n# Origin\r\nThis code of nAdoni is based on the code for an [simple auto-update library for WPF applications](http://blogs.msdn.com/b/dotnetinterop/archive/2008/03/28/simple-auto-update-for-wpf-apps.aspx) which is licensed under the [Ms-PL license](http://opensource.org/licenses/ms-pl).\r\n\r\n[snkfile_msdn]: http://msdn.microsoft.com/en-us/library/6f05ezxy(v=vs.110).aspx","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}